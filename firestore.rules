
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // This function uses get() and MUST NOT be used in rules evaluated during a transaction.
    function isAdmin() {
        return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'Admin';
    }

    // --- User Profile Rules ---
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isOwner(userId);

      // This rule is critical for upvote transactions.
      // It allows a user's points to be updated without using get() calls.
      // It also allows a user to upgrade their own role to 'Investor'.
      allow update: if
        (isSignedIn() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['points'])) ||
        (isOwner(userId) && request.resource.data.role == 'Investor' && resource.data.role == 'User');

      // Deletion is an admin-only action, which is not a transaction, so isAdmin() is safe.
      allow delete: if isAdmin();
    }

    // --- Content Creation Rule ---
    function canCreateContent() {
      // This is not a transaction, so get() is safe here.
      let userRole = get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
      return isSignedIn() && (userRole == 'User' || userRole == 'Admin');
    }
    
    // --- Content Update Rule ---
    function isUpvoting() {
        // Ensures only upvote-related fields are changed in an update.
        return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['upvotes', 'upvotedBy']);
    }

    // --- Problems Collection ---
    match /problems/{problemId} {
      allow read: if true;
      allow create: if canCreateContent();
      // Allow updates for upvoting (no get()) OR for admins approving a price (uses get()).
      allow update: if (isSignedIn() && isUpvoting()) || (isAdmin() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['priceApproved']));
      allow delete: if isAdmin();
    }

    // --- Solutions Collection ---
    match /solutions/{solutionId} {
      allow read: if true;
      allow create: if canCreateContent();
      allow update: if (isSignedIn() && isUpvoting()) || (isAdmin() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['priceApproved']));
      allow delete: if isAdmin();
    }

    // --- Ideas Collection ---
    match /ideas/{ideaId} {
      allow read: if true;
      allow create: if canCreateContent();
      // Ideas have no price, so admins have no special update path beyond deletion.
      allow update: if isSignedIn() && isUpvoting();
      allow delete: if isAdmin();
    }

    // --- Deals and Messages ---
    function isParticipant(dealId) {
        let deal = get(/databases/$(database)/documents/deals/$(dealId)).data;
        return request.auth.uid in [deal.investor.userId, deal.problemCreator.userId, deal.solutionCreator.userId];
    }

    match /deals/{dealId} {
      // Only participants or admins can read/create deals.
      allow read, create: if isParticipant(dealId) || isAdmin();
      // Only admins can modify/delete deals after creation.
      allow update, delete: if isAdmin();
    }

    match /deals/{dealId}/messages/{messageId} {
        // Only participants or admins can read messages.
        allow read: if isParticipant(dealId) || isAdmin();
        // A user must be a participant and the sender to create a message.
        allow create: if isParticipant(dealId) && request.resource.data.sender.userId == request.auth.uid;
        allow update, delete: if isAdmin();
    }

    // --- Notifications ---
    match /notifications/{notificationId} {
      // Admins can read notifications sent to the 'admins' group. Users can read their own.
      allow read: if (resource.data.userId == 'admins' && isAdmin()) || (resource.data.userId == request.auth.uid);
      // Writes are server-side only.
      allow write: if false;
    }
  }
}
