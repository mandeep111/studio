
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function getUserData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    function isRole(userId, role) {
      // Check if user exists before trying to access data
      return exists(/databases/$(database)/documents/users/$(userId)) && getUserData(userId).role == role;
    }

    function isAdmin() {
      return isSignedIn() && isRole(request.auth.uid, 'Admin');
    }
    
    function isUserOrAdmin() {
      return isSignedIn() && (isRole(request.auth.uid, 'User') || isAdmin());
    }

    // --- Users Collection ---
    // Users can be read by anyone.
    // Updates are restricted to the owner, an admin, or for point changes during an upvote.
    match /users/{userId} {
      allow read: if true;
      allow create: if isOwner(userId); // On signup
      allow delete: if isAdmin();
      
      allow update: if 
        // Allow owner or admin to update any field
        isOwner(userId) || isAdmin() ||
        
        // Allow any signed-in user to update another user's points during an upvote transaction.
        // This is a crucial part of the cross-document write for upvoting.
        (
          isSignedIn() && 
          request.auth.uid != userId &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['points'])
        );
    }
    
    // --- Problems, Solutions, Ideas Collections ---
    match /{itemCollection}/{itemId} where itemCollection in ['problems', 'solutions', 'ideas'] {
      allow read: if true;
      allow create: if isUserOrAdmin();
      allow delete: if isAdmin();
      
      // Allow updates for specific actions:
      // 1. An Admin can update anything.
      // 2. A signed-in user can perform a valid upvote action.
      allow update: if 
        isAdmin() ||
        (
          // Upvote action:
          // User must be signed in, not be the creator, and only update upvote fields.
          isSignedIn() && 
          resource.data.creator.userId != request.auth.uid &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['upvotes', 'upvotedBy']) &&
          (request.resource.data.upvotes == resource.data.upvotes + 1 || request.resource.data.upvotes == resource.data.upvotes - 1)
        );
    }
    
    // --- Deals and Subcollections ---
    match /deals/{dealId} {
      // Only participants or admins can access a deal
      function isParticipant() {
        return request.auth.uid in [
          resource.data.investor.userId, 
          resource.data.problemCreator.userId, 
          resource.data.solutionCreator.userId
        ];
      }
    
      allow read, write: if isSignedIn() && (isParticipant() || isAdmin());
      allow create: if isSignedIn() && (isRole(request.auth.uid, 'Investor') || isAdmin()); // Only investors or admins can create deals
      
      // Messages can be created by participants. Other operations inherit from parent.
      match /messages/{messageId} {
        function isDealParticipant() {
          let deal = get(/databases/$(database)/documents/deals/$(dealId)).data;
          return request.auth.uid in [
            deal.investor.userId, 
            deal.problemCreator.userId, 
            deal.solutionCreator.userId
          ];
        }
        allow create: if isSignedIn() && isDealParticipant();
      }
    }
    
    // --- Notifications Collection ---
    match /notifications/{notificationId} {
      // Users can access their own notifications. Admins can access admin notifications.
      allow read, update: if isSignedIn() && 
        (resource.data.userId == request.auth.uid || (resource.data.userId == 'admins' && isAdmin()));
        
      // Notifications are created by trusted server-side logic (Server Actions)
      allow create: if isSignedIn();
    }
  }
}
